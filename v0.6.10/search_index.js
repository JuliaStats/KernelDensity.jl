var documenterSearchIndex = {"docs":
[{"location":"#KernelDensity.jl","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"","category":"section"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"Kernel density estimators for Julia.","category":"page"},{"location":"#Usage","page":"KernelDensity.jl","title":"Usage","text":"","category":"section"},{"location":"#Univariate","page":"KernelDensity.jl","title":"Univariate","text":"","category":"section"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"The main accessor function is kde:","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"U = kde(data)","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"will construct a UnivariateKDE object from the real vector data. The optional keyword arguments are","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"boundary: the lower and upper limits of the kde as a tuple. Due to the fourier transforms used internally, there should be sufficient spacing to prevent wrap-around at the boundaries.\nnpoints: the number of interpolation points to use. The function uses fast Fourier transforms (FFTs) internally, so for optimal efficiency this should be a power of 2 (default = 2048).\nkernel: the distributional family from Distributions.jl to use as the kernel (default = Normal). To add your own kernel, extend the internal kernel_dist function.\nbandwidth: the bandwidth of the kernel. Default is to use Silverman's rule.","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"The UnivariateKDE object U contains gridded coordinates (U.x) and the density estimate (U.density). These are typically sufficient for plotting. A related function","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"kde_lscv(data)","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"will construct a UnivariateKDE object, with the bandwidth selected by least-squares cross validation. It accepts the above keyword arguments, except bandwidth.","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"There are also some slightly more advanced interfaces:","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"kde(data, midpoints::R) where R<:AbstractRange","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"allows specifying the internal grid to use. Optional keyword arguments are kernel and bandwidth.","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"kde(data, dist::Distribution)","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"allows specifying the exact distribution to use as the kernel. Optional keyword arguments are boundary and npoints.","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"kde(data, midpoints::R, dist::Distribution) where R<:AbstractRange","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"allows specifying both the distribution and grid.","category":"page"},{"location":"#Bivariate","page":"KernelDensity.jl","title":"Bivariate","text":"","category":"section"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"The usage mirrors that of the univariate case, except that data is now either a tuple of vectors","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"B = kde((xdata, ydata))","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"or a matrix with two columns","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"B = kde(datamatrix)","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"Similarly, the optional arguments all now take tuple arguments: e.g. boundary now takes a tuple of tuples ((xlo,xhi),(ylo,yhi)).","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"The BivariateKDE object B contains gridded coordinates (B.x and B.y) and the bivariate density estimate (B.density).","category":"page"},{"location":"#Interpolation","page":"KernelDensity.jl","title":"Interpolation","text":"","category":"section"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"The KDE objects are stored as gridded density values, with attached coordinates. These are typically sufficient for plotting (see above), but intermediate values can be interpolated using the Interpolations.jl package via the pdf method (extended from Distributions.jl).","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"pdf(k::UnivariateKDE, x)\npdf(k::BivariateKDE, x, y)","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"where x and y are real numbers or arrays.","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"If you are making multiple calls to pdf, it will be more efficient to construct an intermediate InterpKDE to store the interpolation structure:","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"ik = InterpKDE(k)\npdf(ik, x)","category":"page"},{"location":"","page":"KernelDensity.jl","title":"KernelDensity.jl","text":"InterpKDE will pass any extra arguments to interpolate.","category":"page"},{"location":"#API-Reference","page":"KernelDensity.jl","title":"API Reference","text":"","category":"section"},{"location":"#KernelDensity.BivariateKDE","page":"KernelDensity.jl","title":"KernelDensity.BivariateKDE","text":"mutable struct BivariateKDE{Rx<:AbstractRange, Ry<:AbstractRange} <: KernelDensity.AbstractKDE\n\nStore both grid and density for KDE over the real line.\n\nReading the fields directly is part of the API, and\n\nsum(density) * step(x) * step(y) ≈ 1\n\nFields\n\nx: First coordinate of gridpoints for evaluating the density.\ny: Second coordinate of gridpoints for evaluating the density.\ndensity: Kernel density at corresponding gridpoints Tuple.(x, permutedims(y)).\n\n\n\n\n\n","category":"type"},{"location":"#KernelDensity.UnivariateKDE","page":"KernelDensity.jl","title":"KernelDensity.UnivariateKDE","text":"mutable struct UnivariateKDE{R<:AbstractRange} <: KernelDensity.AbstractKDE\n\nStore both grid and density for KDE over ℝ².\n\nReading the fields directly is part of the API, and\n\nsum(density) * step(x) ≈ 1\n\nFields\n\nx: Gridpoints for evaluating the density.\ndensity: Kernel density at corresponding gridpoints x.\n\n\n\n\n\n","category":"type"},{"location":"#KernelDensity.kde-Union{Tuple{R}, Tuple{AbstractVector{<:Real}, Union{KernelDensity.UniformWeights, AbstractVector{<:Real}}, R, Distributions.UnivariateDistribution}} where R<:AbstractRange","page":"KernelDensity.jl","title":"KernelDensity.kde","text":"kde(data; kwargs...)\nkde((xdata, ydata); kwargs...)\n\nKernel density estimation method. Returns 1D or 2D KDE object. The grid used and the values of the estimated density can be obtained from fields .x and .density respectively. To obtain kde values at points different than the initial grid use the pdf method.\n\nThe keyword arguments are\n\nboundary: the lower and upper limits of the kde, tuple in 1D case, tuple of tuples in 2D case, \nnpoints: the number of interpolation points to use,\nkernel = Normal: the distributional family from Distributions.jl,\nbandwidth: the bandwidth of the kernel; default is calculated using Silverman's rule. \n\n\n\n\n\n","category":"method"},{"location":"#KernelDensity.optimize-Tuple{Any, Any, Any}","page":"KernelDensity.jl","title":"KernelDensity.optimize","text":"optimize(f, x_lower, x_upper; iterations=1000, rel_tol=nothing, abs_tol=nothing)\n\nMinimize the function f in the interval x_lower..x_upper, using the golden-section search. Return an approximate minimum x̃ or error if such approximate minimum cannot be found.\n\nThis algorithm assumes that -f is unimodal on the interval x_lower..x_upper, that is to say, there exists a unique x in x_lower..x_upper such that f is decreasing on x_lower..x and increasing on x..x_upper.\n\nrel_tol and abs_tol determine the relative and absolute tolerance, that is to say, the returned value x̃ should differ from the actual minimum x at most abs_tol + rel_tol * abs(x̃). If not manually specified, rel_tol and abs_tol default to sqrt(eps(T)) and eps(T) respectively, where T is the floating point type of x_lower and x_upper.\n\niterations determines the maximum number of iterations allowed before convergence.\n\nThis is a private, unexported function, used internally to select the optimal bandwidth automatically.\n\n\n\n\n\n","category":"method"}]
}
